<!doctype html>
<html lang="uk">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Carnage Club — Code</title>

    <link rel="stylesheet" href="../styles.css" />

    <style>
        /* Small, consistent code styling without changing global CSS */
        .code-block {
            margin-top: 12px;
            border: 1px solid var(--border);
            background: rgba(255,255,255,0.05);
            border-radius: 14px;
            overflow: hidden;
        }
        pre {
            margin: 0;
            padding: 14px;
            overflow: auto;
            line-height: 1.45;
            font-size: 13px;
            color: rgba(255,255,255,0.88);
        }
        code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
        .pill-row { display:flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }
        .pill {
            display:inline-flex;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: rgba(255,255,255,0.04);
            color: var(--muted);
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
        }
        .two-col {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }
        @media (min-width: 820px){
            .two-col { grid-template-columns: 1fr 1fr; }
        }
    </style>
</head>

<body>
<header class="site-header">
    <nav class="nav">
        <div></div>

        <div class="nav-right">
            <a class="lang-btn projects-btn" href="../projects.html">
                <span data-i18n="ua">Назад</span>
                <span data-i18n="en" hidden>Back</span>
            </a>

            <button class="lang-btn" data-lang="ua" type="button" aria-pressed="false">UA</button>
            <button class="lang-btn" data-lang="en" type="button" aria-pressed="false">EN</button>
        </div>
    </nav>
</header>

<div class="layout" id="top">
    <aside class="side side--left" aria-hidden="true"></aside>

    <main class="center">
        <div class="container">

            <!-- Intro -->
            <section class="section" id="intro">
                <h1>Carnage Club — Code</h1>
                <p>
          <span data-i18n="ua">
            Нижче — приклади коду й технічних рішень з проєкту. Сніпети наведені у “portfolio-friendly” вигляді:
            суть підходу збережена, але деталі можуть бути спрощені для читабельності.
          </span>
                    <span data-i18n="en" hidden>
            Below are code samples and technical solutions from the project. Snippets are shown in a portfolio-friendly form:
            the core approach is preserved, while some details may be simplified for readability.
          </span>
                </p>

                <div class="pill-row">
                    <span class="pill">Unity</span>
                    <span class="pill">C#</span>
                    <span class="pill">Architecture</span>
                    <span class="pill">Telemetry</span>
                    <span class="pill">AI Knowledge</span>
                </div>
            </section>

            <!-- Block 1: Telemetry -->
            <section class="section" id="telemetry">
                <h2>
                    <span data-i18n="ua">Телеметрія бою</span>
                    <span data-i18n="en" hidden>Battle telemetry</span>
                </h2>

                <div class="card">
                    <p>
                        <span data-i18n="ua">
                          Каркас телеметрії збирає вибір дій гравця/AI (атака/захист) і результати резолву по кожному напрямку.
                          Ці дані — “паливо” для шарів знань (патерни гравця, реакційна пам’ять AI).
                        </span>
                        <span data-i18n="en" hidden>
                          Telemetry collects player/AI choices (attack/defense) and resolution outcomes per direction.
                          This data fuels knowledge layers (player behavior patterns, AI reaction memory).
                        </span>
                    </p>

                    <div class="code-block">
<pre><code>// Minimal interface shape
public interface IBattleTelemetryService
{
    void BeginTurn(int roundIndex, CharacterState playerState, CharacterState aiState);

    void RecordTurnChoices(ActorType actor, int[] attackDirs, int[] defendDirs);

    void RecordResolutionOutcomes(int roundIndex, ActorType attacker, List&lt;AttackResolutionResult&gt; results);

    void CompleteTurn(int roundIndex, CharacterState playerState, CharacterState aiState);
}</code></pre>
                    </div>
                </div>
            </section>

            <!-- Block 2: Player Knowledge -->
            <section class="section" id="player-knowledge">
                <h2>
                    <span data-i18n="ua">Знання про звички гравця</span>
                    <span data-i18n="en" hidden>Player behavior knowledge</span>
                </h2>

                <div class="card">
                    <p>
                        <span data-i18n="ua">
                          Шар знань підраховує використання напрямків і патернів (біграми/тріграми) окремо для атаки та захисту.
                          Дані зберігаються у SaveData — “світ пам’ятає ваші звички”.
                        </span>
                        <span data-i18n="en" hidden>
                          This layer tracks direction and pattern usage (bigrams/trigrams) separately for attack and defense.
                          Data is persisted in SaveData — “the world remembers your habits”.
                        </span>
                    </p>

                    <div>
                        <div class="code-block">
<pre><code>// Packed pattern key example: last | (current &lt;&lt; 8)
private static int PackBigram(byte lastMask, byte currentMask)
{
    return lastMask | (currentMask &lt;&lt; 8);
}

// Trigram: a | (b &lt;&lt; 8) | (c &lt;&lt; 16)
private static int PackTrigram(byte a, byte b, byte c)
{
    return a | (b &lt;&lt; 8) | (c &lt;&lt; 16);
}</code></pre>
                        </div>

                        <div class="code-block">
<pre><code>// Direction mask helper (4 directions => bits 0..3)
[Flags]
public enum DirectionMask : byte
{
    None = 0,
    D1 = 1 &lt;&lt; 0,
    D2 = 1 &lt;&lt; 1,
    D3 = 1 &lt;&lt; 2,
    D4 = 1 &lt;&lt; 3,
}

public static class TelemetryMaskUtils
{
    public static DirectionMask ToMask(IReadOnlyList&lt;int&gt; dirs)
    {
        DirectionMask mask = DirectionMask.None;
        for (int i = 0; i &lt; dirs.Count; i++)
            mask |= (DirectionMask)(1 &lt;&lt; (dirs[i] - 1)); // dirs are 1..4
        return mask;
    }
}</code></pre>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Block 3: AI Reaction Knowledge -->
            <section class="section" id="ai-reaction">
                <h2>
                    <span data-i18n="ua">AI Reaction Knowledge</span>
                    <span data-i18n="en" hidden>AI reaction knowledge</span>
                </h2>

                <div class="card">
                    <p>
                        <span data-i18n="ua">
                          Окремий шар реакційної пам’яті AI: матриці “AI атака × блок гравця” та “атака гравця × блок AI”.
                          Кожна клітинка збирає статистику (влучання/блок/парирування/гвард-брейк, сумарний урон) і використовується
                          для оцінки найкращих рішень.
                        </span>
                        <span data-i18n="en" hidden>
                          A separate AI reaction memory layer: matrices for “AI attack × player block” and “player attack × AI block”.
                          Each cell aggregates stats (hit/block/parry/guard break, damage sums) and is used to score the best decisions.
                        </span>
                    </p>

                    <div class="code-block">
<pre><code>// Packed cell key: attackDir | (defMask &lt;&lt; 8) | (isDefense ? 0x10000 : 0)
public readonly struct ReactionCellKey
{
    public readonly int Key;

    public ReactionCellKey(int attackDir, int defMask, bool isDefenseMatrix)
    {
        Key = (attackDir &amp; 0xFF) | ((defMask &amp; 0xFF) &lt;&lt; 8) | (isDefenseMatrix ? 0x10000 : 0);
    }
}</code></pre>
                    </div>

                    <div class="code-block">
<pre><code>// Very simplified scoring example
public static float ScoreCell(ReactionCellStats s, float guardWeight, float blockPenalty)
{
    if (s.Uses &lt; 3) return 0f; // cold start
    float hitRate = (float)s.HitCount / s.Uses;
    float blockRate = (float)s.BlockedCount / s.Uses;

    return (hitRate * 1.0f)
         + (s.GuardBreakCount * guardWeight / s.Uses)
         - (blockRate * blockPenalty);
}</code></pre>
                    </div>
                </div>
            </section>

            <!-- Block 4: Architecture / Services -->
            <section class="section" id="architecture">
                <h2>
                    <span data-i18n="ua">Архітектура сервісів</span>
                    <span data-i18n="en" hidden>Service architecture</span>
                </h2>

                <div class="card">
                    <p>
                        <span data-i18n="ua">
                          Проєкт використовує Service Locator / DI-подібний підхід: сервіси — прості C# класи (без MonoBehaviour),
                          реєстрація в AppStartup, логування централізоване. Це зменшує зв’язність і полегшує тести.
                        </span>
                        <span data-i18n="en" hidden>
                          The project follows a Service Locator / DI-like approach: services are plain C# classes (no MonoBehaviour),
                          registered in AppStartup, with centralized logging. This reduces coupling and helps testing.
                        </span>
                    </p>

                    <div class="code-block">
<pre><code>public static class AppStartup
{
    public static void InitializeServices(IServiceLocator services)
    {
        services.Register&lt;IRandomService&gt;(new DefaultRandomService());
        services.Register&lt;IBattleTelemetryService&gt;(new BattleTelemetryService());
        services.Register&lt;IKnowledgeService&gt;(new KnowledgeService());
    }
}</code></pre>
                    </div>
                </div>
            </section>

            <!-- Block 5: Bandit tactics + контекстний exploration -->
            <section class="section" id="ai-bandit">
                <h2>
                    <span data-i18n="ua">Bandit tactics + контекстний exploration</span>
                    <span data-i18n="en" hidden>Bandit tactics + contextual exploration</span>
                </h2>

                <div class="card">
                    <p>
                        <span data-i18n="ua">Вибір дій через Thompson Sampling (exploitation) та керований exploration з урахуванням контексту бою. Показую лише форму/ідею — без усіх деталей тюнінгу та внутрішніх структур.</span>
                        <span data-i18n="en" hidden>Action selection via Thompson Sampling (exploitation) and guided exploration that adapts to combat context. This is an idea/shape excerpt — tuning and internal details are intentionally omitted.</span>
                    </p>

                    <div class="code-block">
<pre><code>// bandit + contextual exploration
public sealed class AiDecisionSelectionService
{
    private const int TopN = 6;
    private const float KnowledgeBiasMin = 0.2f;

    public CandidateWithScore SelectAction(
        IReadOnlyList&lt;CandidateWithScore&gt; candidates,
        CombatContext context,
        int roundIndex,
        TacticalDirective directive)
    {
        // 1) Decide: explore vs exploit (epsilon is context-aware + decays over time)
        float exploreRoll = randomService.NextFloat01();
        bool shouldExplore = explorationBudget.ShouldExplore(context, exploreRoll, roundIndex, directive.ExplorationBias);

        // 2) Exploit: Thompson sampling over Beta priors (knowledge + learned trials)
        if (!shouldExplore)
            return thompson.SelectTopBySample(candidates, banditStats);

        // 3) Explore (guided): weighted-random among TopN
        //    weight = uncertainty(uses) * knowledgeBias(score)
        var top = TakeTopN(candidates, TopN);
        return PickWeighted(top, c =&gt; Uncertainty(c.ActionKey) * KnowledgeBias(c.KnowledgeScore));
    }

    private float Uncertainty(string actionKey)
    {
        // Higher when an arm has fewer considerations; encourages trying “unknown” options.
        int uses = banditStats.GetUses(actionKey);
        return 1f / Mathf.Sqrt(uses + 1);
    }

    private float KnowledgeBias(int knowledgeScore)
    {
        // Clamp score to [-100..100], then map to [KnowledgeBiasMin..1]
        float t = Mathf.InverseLerp(-100f, 100f, Mathf.Clamp(knowledgeScore, -100, 100));
        return Mathf.Lerp(KnowledgeBiasMin, 1f, t);
    }
}</code></pre>
                    </div>

                    <div class="code-block">
<pre><code>// Bandit arm statistics (excerpt): knowledge-based prior + learned outcomes
public sealed class BanditArmStats
{
    public int Uses { get; private set; } // number of times this arm was considered
    private float priorAlpha, priorBeta;  // derived from knowledgeScore
    private int learnedSuccesses, learnedFailures;

    public float EstimatedMeanReward()
    {
        float a = priorAlpha + learnedSuccesses;
        float b = priorBeta  + learnedFailures;
        return a / (a + b);
    }

    public void RecordConsideration() =&gt; Uses++;
    public void RecordTurnOutcome(float reward)
    {
        if (reward &gt; 0f) learnedSuccesses++;
        else learnedFailures++;
    }

    public void UpdateKnowledge(int knowledgeScore)
    {
        // Resets the prior from reaction-knowledge score (details omitted for brevity)
        (priorAlpha, priorBeta) = BuildPriorFromScore(knowledgeScore);
    }
}</code></pre>
                    </div>
                </div>
            </section>

            <!-- Block 6: GOAP-lite intent planner + Soft FSM (hysteresis) -->
            <section class="section" id="ai-intent-fsm">
                <h2>
                    <span data-i18n="ua">GOAP-lite intent planner + Soft FSM (hysteresis)</span>
                    <span data-i18n="en" hidden>GOAP-lite intent planner + Soft FSM (hysteresis)</span>
                </h2>

                <div class="card">
                    <p>
                        <span data-i18n="ua">High-level intent (Pressure/Survive/Punish) обирається утилітарним планером з інерцією, а Soft FSM стабілізує переходи (поріг, мін/макс стабільність) і має критичні override’и для ключових ситуацій.</span>
                        <span data-i18n="en" hidden>High-level intent (Pressure/Survive/Punish) is chosen by a utility planner with inertia, while a Soft FSM stabilizes transitions (threshold, min/max stability) and applies critical overrides for key situations.</span>
                    </p>

                    <div class="code-block">
<pre><code>// GOAP-lite intent planner (utility + inertia)
public sealed class AiIntentPlanner : IAiIntentPlanner
{
    private const float InertiaBonus = 0.10f;

    public IntentPlanResult PlanIntent(CombatContext ctx, KnowledgeSummary k, ActiveIntentState prev)
    {
        if (k == null)
            return IntentPlanResult.DefaultSurvive(ctx); // safe fallback

        float pressure = ScorePressure(ctx, k);
        float survive  = ScoreSurvive(ctx, k);
        float punish   = ScorePunish(ctx, k);

        // Inertia: stabilize behavior to avoid “twitchy” intent switching
        if (prev != null)
        {
            if (prev.CurrentIntent == AiIntentType.Pressure) pressure += InertiaBonus;
            if (prev.CurrentIntent == AiIntentType.Survive)  survive  += InertiaBonus;
            if (prev.CurrentIntent == AiIntentType.Punish)   punish   += InertiaBonus;
        }

        pressure = Mathf.Clamp01(pressure);
        survive  = Mathf.Clamp01(survive);
        punish   = Mathf.Clamp01(punish);

        AiIntentType best = ArgMax(pressure, survive, punish);
        return IntentPlanResult.From(best, pressure, survive, punish, ctx);
    }

    // Score*() methods use context + knowledge (success rates, predictability, repetition…)
    // Full tuning is intentionally omitted.
}</code></pre>
                    </div>

                    <div class="code-block">
<pre><code>// Soft FSM executor (excerpt): hysteresis + critical overrides
public sealed class AiSoftFsmExecutor : IAiSoftFsmExecutor
{
    private const float TransitionThreshold = 0.15f;
    private const int MinStableTurns = 2;
    private const int MaxStableTurns = 8;

    public bool EvaluateTransition(ActiveIntentState state, IntentPlanResult plan, CombatContext ctx, KnowledgeSummary k, int turn)
    {
        // Critical overrides first (high-stakes / high-signal situations)
        if (ctx == CombatContext.AILowHealth)
            return state.TryTransition(AiIntentType.Survive, turn, &quot;critical_low_hp&quot;);

        if (k != null &amp;&amp; k.PlayerPredictability &gt;= 0.80f &amp;&amp; k.KnowledgeConfidence &gt;= 0.60f &amp;&amp; k.TotalTurns &gt;= 3)
            return state.TryTransition(AiIntentType.Punish, turn, &quot;critical_high_predictability&quot;);

        // Hysteresis: only switch if the new plan is clearly better and we&#x27;ve been stable long enough
        if (state.TurnsActive &lt; MinStableTurns)
            return false;

        float current = plan.UtilityScores[state.CurrentIntent];
        float target  = plan.UtilityScores[plan.SelectedIntent];
        if (target - current &gt;= TransitionThreshold)
            return state.TryTransition(plan.SelectedIntent, turn, $&quot;utility_delta:{target-current:0.00}&quot;);

        // Prevent being stuck forever
        if (state.TurnsActive &gt;= MaxStableTurns)
            return state.TryTransition(plan.SelectedIntent, turn, &quot;max_stable_turns&quot;);

        return false;
    }
}</code></pre>
                    </div>
                </div>
            </section>

            <!-- Placeholder -->
            <section class="section" id="next">
                <h2>
                    <span data-i18n="ua">Далі буде більше</span>
                    <span data-i18n="en" hidden>More coming soon</span>
                </h2>

                <div class="card">
                    <p>
                        <span data-i18n="ua">
                          Тут з’являться додаткові приклади: UI контролери, тулінг, профілювання,
                          та реальні фрагменти з продакшен-коду (у межах того, що можна публічно показувати).
                        </span>
                        <span data-i18n="en" hidden>
                          More samples will be added here: UI controllers, tooling, profiling,
                          and production-ready snippets (within what can be shared publicly).
                        </span>
                    </p>
                </div>
            </section>

            <footer class="footer">
        <span>© <span id="year"></span>
          <span data-i18n="ua">Тарасенко Дмитро</span>
          <span data-i18n="en" hidden>Tarasenko Dmytro</span>
        </span>
            </footer>

        </div>
    </main>

    <aside class="side side--right" aria-hidden="true"></aside>
</div>

<script src="../assets/js/i18n.js"></script>
<script>
    document.getElementById("year").textContent = new Date().getFullYear();
</script>
</body>
</html>